package com.training.rajesh.stream.grouping;

import static java.util.Comparator.comparingLong;
import static java.util.stream.Collectors.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Stream;

import org.junit.Before;
import org.junit.Test;

import com.training.rajesh.stream.Countries;
import com.training.rajesh.stream.Country;

public class Grouping {
	static final List<Country> countries = Countries.getCountries();
	Stream<Country> countryStream;

	@Before
	public void initStream() {

		countryStream = countries.stream();
	}

	@Test
	public void countriesPerContinent() {
		Map<String, Long> countriesPerContinent = countryStream.collect(groupingBy(Country::getContinent, counting()));
		System.out.println(countriesPerContinent);
	}

	@Test
	public void countriesByContinent() {
		Map<String, List<Country>> countriesByContinent = countryStream.collect(groupingBy(Country::getContinent));
		System.out.println(countriesByContinent);
	}

	@Test
	public void countriesByPopulation() {
		Map<String, List<Country>> countriesByPopulation = countryStream.collect(groupingBy(country -> {
			if (country.getPopulation() >= 30000000L)
				return "higlypopulated";
			else
				return "lesspopulated";
		}));
		System.out.println(countriesByPopulation);
	}

	@Test
	public void countriesByContinentAndByPopulation() {
		// multi level grouping
		Map<String, Map<String, List<Country>>> countriesByContinentAndByPopulation = countryStream
				.collect(groupingBy(Country::getContinent, groupingBy(country -> {
					if (country.getPopulation() >= 30000000L)
						return "higlypopulated";
					else
						return "lesspopulated";
				})));

		System.out.println(countriesByContinentAndByPopulation);
	}

	@Test
	public void maxPopulatedCountryInEachContinent() {
		Map<String, Optional<Country>> contries = countryStream
				.collect(groupingBy(Country::getContinent, maxBy(comparingLong(Country::getPopulation))));

		System.out.println(contries);
	}

	@Test
	public void collectingAndThenExample(){
		
		/*
		 * This factory method takes two arguments, the collector to be adapted
		 * and a transformation function, and returns another collector. This
		 * additional collector acts as a wrapper for the old one and maps the
		 * value it returns using the transformation function as the last step
		 * of the collect operation. In this case, the wrapped collector is the
		 * one created with maxBy, and the transformation function,
		 * Optional::get, extracts the value contained in the Optional returned.
		 */	
		
		Map<String, Country> contries =	countryStream.
															collect(
															groupingBy(Country::getContinent,
															collectingAndThen(maxBy(comparingLong(Country::getPopulation)),Optional::get)));
	 
			
			 System.out.println(contries);
	}
	
	@Test
	public void groupingByExample(){
			
		/*
		 * Yet another collector, commonly used in conjunction with groupingBy,
		 * is one generated by the mapping method. This method takes two
		 * arguments: a function transforming the elements in a stream and a
		 * further collector accumulating the objects resulting from this
		 * transformation. Its purpose is to adapt a collector accepting
		 * elements of a given type to one working on objects of a different
		 * type, by applying a mapping function to each input element before
		 * accumulating them.
		 */	
		Map<String, Map<String, List<Country>>> countriesByContinentAndByPopulation = countryStream
				.collect(groupingBy(Country::getContinent, map(country -> {
					if (country.getPopulation() >= 30000000L)
						return "higlypopulated";
					else
						return "lesspopulated";
				})));

		System.out.println(countriesByContinentAndByPopulation);
	
	}
}
